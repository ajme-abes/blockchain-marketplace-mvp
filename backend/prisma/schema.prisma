generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                       String    @id @default(uuid())
  email                    String    @unique
  passwordHash             String
  name                     String
  phone                    String?   @unique
  role                     UserRole  @default(BUYER)
  address                  String?
  avatarUrl                String?
  region                   String?
  bio                      String?   
  languagePreference       String    @default("en")
  registrationDate         DateTime  @default(now())
  walletAddress            String?
  emailVerified            Boolean   @default(false)
  verificationToken        String?   @unique
  verificationTokenExpires DateTime?
  resetToken               String?   @unique
  resetTokenExpires        DateTime?
  status UserStatus @default(ACTIVE)

  // Relations
  chatParticipants ChatParticipant[]
  sentMessages     Message[]
  messageReads     MessageRead[]
  producerProfile      Producer?
  buyerProfile         Buyer?
  orders               Order[]               @relation("UserOrders")
  paymentConfirmations PaymentConfirmation[] @relation("UserPaymentConfirmations")
  notifications        Notification[]
  auditLogs            AuditLog[]
  sessions             Session[]
  ipfsFiles            IPFSMetadata[]
  statusHistoryChanges OrderStatusHistory[]

  disputesRaised   Dispute[]         @relation("UserDisputesRaised")
  disputesResolved Dispute[]         @relation("UserDisputesResolved")
  disputeEvidences DisputeEvidence[]
  disputeMessages  DisputeMessage[]

  @@index([email])
  @@index([role])
  @@index([registrationDate])
  @@index([email, role])
  @@index([phone])
  @@map("users")
}

model Producer {
  id                 String             @id @default(uuid())
  businessName       String
  location           String
  verificationStatus VerificationStatus @default(PENDING)
  rejectionReason    String?

  // Relations
  userId   String    @unique
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  products Product[]
  documents      ProducerDocument[]

  @@index([verificationStatus])
  @@index([businessName])
  @@index([userId])
  @@map("producers")
}

model ProducerDocument {
  id          String   @id @default(uuid())
  producerId  String
  type        String   // LICENSE, TAX_ID, BUSINESS_REGISTRATION, etc.
  url         String
  filename    String
  fileSize    Int?
  mimeType    String?
  uploadedAt  DateTime @default(now())

  // Relations - ONLY ONE RELATION NEEDED
  producer    Producer @relation(fields: [producerId], references: [id], onDelete: Cascade)

  @@index([producerId])
  @@index([type]) // Changed from documentType to type
  @@map("producer_documents")
}

model Buyer {
  id                     String @id @default(uuid())
  preferredPaymentMethod String @default("CHAPA")

  // Relations
  userId  String   @unique
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders  Order[]  @relation("BuyerOrders")
  reviews Review[]

  @@index([userId])
  @@map("buyers")
}

model Product {
  id                String        @id @default(uuid())
  name              String
  category          String
  chats Chat[] @relation("ProductChats")
  price             Float
  quantityAvailable Int
  description       String?
  imageUrl          String?
  status            ProductStatus @default(ACTIVE)
  listingDate       DateTime      @default(now())
  averageRating     Float?        @default(0)
  reviewCount       Int?          @default(0)

  // Relations
  producerId String
  producer   Producer       @relation(fields: [producerId], references: [id], onDelete: Cascade)
  orderItems OrderItem[]
  reviews    Review[]
  ipfsFiles  IPFSMetadata[]

  @@index([name])
  @@index([category])
  @@index([price])
  @@index([status])
  @@index([producerId])
  @@index([listingDate])
  @@index([category, status])
  @@index([price, category])
  @@index([status, listingDate])
  @@map("products")
}

model Order {
  id               String         @id @default(uuid())
  totalAmount      Float
  paymentStatus    PaymentStatus  @default(PENDING)
  deliveryStatus   DeliveryStatus @default(PENDING)
  orderDate        DateTime       @default(now())
  chat Chat? @relation("OrderChat")
  blockchainTxHash String?       @unique
  blockchainOrderId    String?   @unique  
  blockchainRecorded   Boolean?  @default(false)
  blockchainError      String?   
  
  shippingAddress  Json?
  updatedAt        DateTime       @updatedAt

  // Relations
  buyerId              String
  buyer                Buyer                 @relation(fields: [buyerId], references: [id], onDelete: Cascade, name: "BuyerOrders")
  userId               String? // For the User relation
  user                 User?                 @relation(fields: [userId], references: [id], name: "UserOrders")
  orderItems           OrderItem[]
  paymentConfirmations PaymentConfirmation[]
  blockchainRecords    BlockchainRecord[]
  statusHistory        OrderStatusHistory[]
  paymentReferences    PaymentReference[]

  dispute Dispute?

  @@index([buyerId])
  @@index([paymentStatus])
  @@index([deliveryStatus])
  @@index([orderDate])
  @@index([blockchainTxHash])
  @@index([buyerId, orderDate])
  @@index([paymentStatus, deliveryStatus])
  @@index([orderDate, paymentStatus])
  @@map("orders")
}

model OrderItem {
  id       String @id @default(uuid())
  quantity Int
  subtotal Float
  price    Float

  // Relations
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id])

  @@unique([orderId, productId])
  @@index([orderId])
  @@index([productId])
  @@map("order_items")
}

model OrderStatusHistory {
  id          String         @id @default(uuid())
  orderId     String
  order       Order          @relation(fields: [orderId], references: [id], onDelete: Cascade)
  fromStatus  DeliveryStatus
  toStatus    DeliveryStatus
  changedById String
  changedBy   User           @relation(fields: [changedById], references: [id])
  reason      String?
  createdAt   DateTime       @default(now())

  @@index([orderId])
  @@index([createdAt])
  @@index([changedById])
  @@index([fromStatus])
  @@index([toStatus])
  @@map("order_status_history")
}

model PaymentConfirmation {
  id                 String        @id @default(uuid())
  confirmationMethod PaymentMethod
  confirmedAt        DateTime
  isConfirmed        Boolean       @default(false)
  proofImageUrl      String?
  blockchainTxHash   String?

  // Relations
  orderId       String
  order         Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  confirmedById String
  confirmedBy   User   @relation(fields: [confirmedById], references: [id], name: "UserPaymentConfirmations")

  @@index([orderId])
  @@index([confirmedById])
  @@index([confirmedAt])
  @@index([confirmationMethod])
  @@map("payment_confirmations")
}

model PaymentReference {
  id          String    @id @default(uuid())
  orderId     String
  order       Order     @relation(fields: [orderId], references: [id], onDelete: Cascade)
  paymentCode String    @unique
  generatedAt DateTime  @default(now())
  usedAt      DateTime?

  @@index([orderId])
  @@index([paymentCode])
  @@index([generatedAt])
  @@map("payment_references")
}

model BlockchainRecord {
  id          String    @id @default(uuid())
  txHash      String    @unique
  blockNumber String?
  timestamp   DateTime?
  status      String    @default("pending")

  // Relations
  orderId String
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId])
  @@index([txHash])
  @@index([timestamp])
  @@index([status])
  @@map("blockchain_records")
}

model Review {
  id         String   @id @default(uuid())
  rating     Int // 1-5 stars
  comment    String?
  reviewDate DateTime @default(now())

  // Relations
  buyerId   String
  buyer     Buyer   @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  productId String
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([buyerId, productId])
  @@index([buyerId])
  @@index([productId])
  @@index([rating])
  @@index([reviewDate])
  @@map("reviews")
}

model Notification {
  id        String             @id @default(uuid())
  message   String
  type      NotificationType
  status    NotificationStatus @default(UNREAD)
  createdAt DateTime           @default(now())

  // Relations
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([userId, status])
  @@map("notifications")
}

// NEW MODELS

model AuditLog {
  id        String   @id @default(uuid())
  action    String
  entity    String
  entityId  String
  oldValues Json?
  newValues Json?
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: NoAction)
  ipAddress String?
  userAgent String?
  timestamp DateTime @default(now())

  @@index([action])
  @@index([entity, entityId])
  @@index([timestamp])
  @@index([userId])
  @@index([entity, timestamp])
  @@map("audit_logs")
}

model Session {
  id           String   @id @default(uuid())
  userId       String
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token        String   @unique
  refreshToken String?  @unique
  expiresAt    DateTime
  ipAddress    String?
  userAgent    String?
  isValid      Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([token])
  @@index([refreshToken])
  @@index([expiresAt])
  @@index([isValid])
  @@index([createdAt])
  @@index([userId, isValid])
  @@index([expiresAt, isValid])
  @@map("sessions")
}

model IPFSMetadata {
  id        String       @id @default(uuid())
  cid       String       @unique
  name      String?
  mimeType  String?
  size      Int?
  category  IPFSCategory
  userId    String?
  user      User?        @relation(fields: [userId], references: [id], onDelete: NoAction)
  productId String?
  product   Product?     @relation(fields: [productId], references: [id], onDelete: NoAction)
  createdAt DateTime     @default(now())

  @@index([cid])
  @@index([category])
  @@index([userId])
  @@index([productId])
  @@index([createdAt])
  @@index([category, createdAt])
  @@map("ipfs_metadata")
}

// ENUMS
enum UserRole {
  BUYER
  PRODUCER
  ADMIN
}

enum VerificationStatus {
  PENDING
  VERIFIED
  REJECTED
}

enum ProductStatus {
  ACTIVE
  INACTIVE
  OUT_OF_STOCK
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  FAILED
  REFUNDED
}

enum DeliveryStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}

enum PaymentMethod {
  CHAPA
  ARIFPAY
  MANUAL
}

enum NotificationType {
  ORDER_CREATED
  PAYMENT_CONFIRMED
  ORDER_SHIPPED
  DISPUTE_RAISED
  REVIEW_RECEIVED
  GENERAL
  SECURITY
  SYSTEM
}

enum NotificationStatus {
  READ
  UNREAD
}

// NEW ENUMS
enum IPFSCategory {
  PRODUCT_IMAGE
  USER_AVATAR
  DOCUMENT
  PAYMENT_PROOF
  BUSINESS_LICENSE
}
enum UserStatus {
  ACTIVE
  SUSPENDED  
  INACTIVE
  BANNED
}

model Dispute {
  id           String        @id @default(uuid())
  orderId      String        @unique
  order        Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  raisedById   String
  raisedBy     User          @relation("UserDisputesRaised", fields: [raisedById], references: [id], onDelete: Cascade)
  reason       String
  description  String?
  status       DisputeStatus @default(OPEN)
  resolution   String?
  resolvedById String?
  resolvedBy   User?         @relation("UserDisputesResolved", fields: [resolvedById], references: [id], onDelete: NoAction)
  resolvedAt   DateTime?
  refundAmount Float?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Relations
  evidence DisputeEvidence[]
  messages DisputeMessage[]

  @@index([orderId])
  @@index([raisedById])
  @@index([status])
  @@index([createdAt])
  @@index([raisedById, status])
  @@map("disputes")
}

model DisputeEvidence {
  id           String       @id @default(uuid())
  disputeId    String
  dispute      Dispute      @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  type         EvidenceType
  url          String // IPFS URL for files
  filename     String?
  fileSize     Int?
  mimeType     String?
  uploadedById String
  uploadedBy   User         @relation(fields: [uploadedById], references: [id], onDelete: Cascade)
  uploadedAt   DateTime     @default(now())
  description  String?

  @@index([disputeId])
  @@index([type])
  @@index([uploadedById])
  @@map("dispute_evidence")
}

model DisputeMessage {
  id         String             @id @default(uuid())
  disputeId  String
  dispute    Dispute            @relation(fields: [disputeId], references: [id], onDelete: Cascade)
  senderId   String
  sender     User               @relation(fields: [senderId], references: [id], onDelete: Cascade)
  content    String
  type       DisputeMessageType @default(MESSAGE)
  isInternal Boolean            @default(false)
  createdAt  DateTime           @default(now())

  @@index([disputeId])
  @@index([senderId])
  @@index([createdAt])
  @@index([disputeId, createdAt])
  @@map("dispute_messages")
}


model Chat {
  id           String         @id @default(uuid())
  participants ChatParticipant[]
  messages     Message[]
  orderId      String?        @unique
  order        Order?         @relation("OrderChat", fields: [orderId], references: [id], onDelete: Cascade)
  productId    String?
  product      Product?       @relation("ProductChats", fields: [productId], references: [id], onDelete: Cascade)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  lastMessageAt DateTime?

  @@index([orderId])
  @@index([productId])
  @@index([createdAt])
  @@index([updatedAt])
  @@index([lastMessageAt])
  @@map("chats")
}

model ChatParticipant {
  id        String   @id @default(uuid())
  chatId    String
  chat      Chat     @relation(fields: [chatId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  joinedAt  DateTime @default(now())
  lastReadAt DateTime?

  @@unique([chatId, userId])
  @@index([chatId])
  @@index([userId])
  @@index([lastReadAt])
  @@map("chat_participants")
}

model Message {
  id           String         @id @default(uuid())
  content      String
  messageType  MessageType    @default(TEXT)
  senderId     String
  sender       User           @relation(fields: [senderId], references: [id], onDelete: Cascade)
  chatId       String
  chat         Chat           @relation(fields: [chatId], references: [id], onDelete: Cascade)
  readBy       MessageRead[]
  attachments  MessageAttachment[]
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@index([chatId])
  @@index([senderId])
  @@index([createdAt])
  @@index([chatId, createdAt])
  @@map("messages")
}

model MessageRead {
  id         String   @id @default(uuid())
  messageId  String
  message    Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  readAt     DateTime @default(now())

  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@index([readAt])
  @@map("message_reads")
}

model MessageAttachment {
  id        String            @id @default(uuid())
  messageId String
  message   Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)
  fileName  String?
  fileUrl   String
  fileType  String
  fileSize  Int?
  ipfsCid   String?
  createdAt DateTime          @default(now())

  @@index([messageId])
  @@index([fileType])
  @@index([createdAt])
  @@map("message_attachments")
}

// ENUMS
enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum ChatType {
  ORDER
  PRODUCT_INQUIRY
  GENERAL
}
enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  CANCELLED
  REFUNDED
}

enum EvidenceType {
  IMAGE
  DOCUMENT
  VIDEO
  SCREENSHOT
  OTHER
}

enum DisputeMessageType {
  MESSAGE
  INTERNAL_NOTE
  RESOLUTION_UPDATE
  STATUS_CHANGE
}
